小Q十分富有，拥有非常多的硬币，小Q拥有的硬币是有规律的，对于所有的非负整数K，小Q恰好各有两个面值为2^K的硬币，所以小Q拥有的硬币就是1,1,2,2,4,4,8,8,…。小Q有一天去商店购买东西需要支付n元钱，小Q想知道有多少种方案从他拥有的硬币中选取一些拼凑起来恰好是n元（如果两种方案某个面值的硬币选取的个数不一样就考虑为不一样的方案）。

 

输入描述：
输入包括一个整数n(1≤n≤10^18)，表示小Q需要支付多少钱。注意n的范围。
输出描述：
输出一个整数，表示小Q可以拼凑出n元钱放的方案数。
示例1
输入：
6
输出：
3

//考虑二进制加法，当前数为偶数时，最低位为0可能是由该位的两个硬币进位导致，或者直接没选该位的硬币，共有两种可能；为奇数时最低位硬币必被选，只有一种可能。
#include<iostream>
#include<map>
using namespace std;
map<long, long> m;
 
long solve(long n){  //记忆搜索法
    if(m.count(n)) return m[n]; //如果已有直接返回
    long count = 0;
    if((n&1) != 1) count = solve(n>>1) + solve((n-2)>>1);  
    /*假设 n 为偶数：
    n = a0*2^k0 + a1*2^k1 + ... + ak*2^kn 
    ==> 右式提取2 ==>
    n = 2(a0*2^k0-1 + a1*2^k0-2 + ... + ak*2^kn-1)
    ==> 两边除以2 ==>
    (n/2) = a0*2^k0-1 + a1*2^k0-2 + ... + ak*2^kn-1
    所以(n)和(n/2)的组合选择，总数量是一样的，因为所有a的选择方式没变。对于使用了1的情况来说，如果是奇数则必只能有1个1，是偶数则必有2个1，它的a是完全确定的，
    所以先将它去掉不影响组合数，但会决定递归的路径，所以偶数要考虑两种情况，有1或没有1，奇数则只有有1的一种情况。*/
    else count = solve((n-1)>>1);  //n为奇数
    m[n] = count;
    return count;
}
 
int main(){
    m[0] = 1; m[1] = 1;  //初始值
    long n; cin>>n;
    cout<<solve(n)<<endl;
    return 0;
}
